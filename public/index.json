[{"categories":["前端","JavaScript"],"contents":"","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","JavaScript"],"contents":"","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","JavaScript"],"contents":"","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 從前做 Java 後端經歷過它麻煩又嚴謹的開發規則，到後來做行動網銀沒有使用框架，用 ES5 的自由奔放( var 就對了 )\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 從前做 Java 後端經歷過它麻煩又嚴謹的開發規則，到後來做行動網銀沒有使用框架，用 ES5 的自由奔放( #var 就對了# )\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 從前做 Java 後端經歷過它麻煩又嚴謹的開發規則，到後來做行動網銀沒有使用框架，用 ES5 的自由奔放( #var 就對了# )\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 從前做 Java 後端經歷過它麻煩又嚴謹的開發規則，到後來做行動網銀沒有使用框架，用 ES5 的自由奔放( var 就對了 )\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 Java 在程式設計上非常嚴謹，需事先定義好每一個變數的資料類型、方法的參數和回傳值，並且在編譯階段就會檢查你的程式碼是否有任何錯誤。這種嚴格的規則雖然會增加一些開發初期的工作量，卻能有效避免執行時的錯誤，提高程式碼的穩定性。\n相較之下，JavaScript ES5 就顯得自由奔放許多，它允許在程式執行過程中動態改變變數的型別，給開發者帶來很大的靈活性。但是，這種靈活性也帶來了一些隱患，如果沒有良好的程式設計習慣，很容易寫出不易維護且容易出錯的程式碼。\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 Java 在程式設計上非常嚴謹，需事先定義好每一個變數的資料類型、方法的參數和回傳值，並且在編譯階段就會檢查你的程式碼是否有任何錯誤。這種嚴格的規則雖然會增加一些開發初期的工作量，卻能有效避免執行時的錯誤，提高程式碼的穩定性。\n相較之下，JavaScript ES5 就顯得自由奔放許多，它允許在程式執行過程中動態改變變數的型別，給開發者帶來很大的靈活性。但是，這種靈活性也帶來了一些隱患，如果沒有良好的程式設計習慣，很容易寫出不易維護且容易出錯的程式碼。\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/temp/","section":"post","tags":null,"title":""},{"categories":["前端","TypeScript"],"contents":"前言 Java 在程式設計上非常嚴謹，需事先定義好每一個變數的資料類型、方法的參數和回傳值，並且在編譯階段就會檢查你的程式碼是否有任何錯誤。這種嚴格的規則雖然會增加一些開發初期的工作量，卻能有效避免執行時的錯誤，提高程式碼的穩定性。\n相較之下，JavaScript ES5 就顯得自由奔放許多，它允許在程式執行過程中動態改變變數的型別，給開發者帶來很大的靈活性。但是，這種靈活性也帶來了一些隱患，如果沒有良好的程式設計習慣，很容易寫出不易維護且容易出錯的程式碼。\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 Java 在程式設計上非常嚴謹，需事先定義好每一個變數的資料類型、方法的參數和回傳值，並且在編譯階段就會檢查你的程式碼是否有任何錯誤。這種嚴格的規則雖然會增加一些開發初期的工作量，卻能有效避免執行時的錯誤，提高程式碼的穩定性。\n相較之下，JavaScript ES5 就顯得自由奔放許多，它允許在程式執行過程中動態改變變數的型別，給開發者帶來很大的靈活性。但是，這種靈活性也帶來了一些隱患，如果沒有良好的程式設計習慣，很容易寫出不易維護且容易出錯的程式碼。\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 菜鸟教程\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 菜鸟教程\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (_關於 TDZ，我們以後會專門做一期影片跟大家講解_)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 link ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 參考資料Why use Type and not Interface in TypeScript ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 參考資料 Why use Type and not Interface in TypeScript ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 參考資料 - - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"TypeScript 型別系統： Type 與 Interface 的抉擇與搭配 在 TypeScript 的世界裡，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著微妙的差異。本文將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法\nSignals 與 ref 的比較 特性 Type Interface 定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法\n** Type 與 Interface 的比較 ** 特性 Type Interface 定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法\nType 與 Interface 的比較 特性 Type Interface 定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法\nType 與 Interface 的比較 特性 Type Interface 定義 為任意型別命名 主要用於定義物件的結構 宣告方式 type 變數名 = 型別; interface 介面名稱 { \u0026hellip; } 繼承 可以繼承任何型別 只能繼承其他介面 重新宣告 可以重複宣告，後面的宣告會覆蓋前面的 不能重複宣告 使用場景 聯合型別、交叉型別、函式型別等 定義物件的屬性和方法 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\nType 與 Interface 的比較 // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\nType 與 Interface 的比較 // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\nType 與 Interface 的比較 擴展(extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\nType 與 Interface 的比較 1. 擴展(extends)的語法差異:\n// Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\nType 與 Interface 的比較 1. 擴展(extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3. // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型 // 這樣寫是不行的 interface DuplicateString { [key in Keys]: string; // 錯誤 } 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4. // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 參考資料 - Why use Type and not Interface in TypeScript\n","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 參考資料\nWhy use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 參考資料\nWhy use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 參考資料\nWhy use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 個人認為無論使用哪一種方式都好，主要是跟團隊建立好專案的 Coding Guideline 但若以獨立開發來說，根據過往經驗，從一開始做 Java 開發，到後來接觸前端也是習慣用 Interface 來做，畢竟這也比較接近 OOP 的概念，後續深入研究前端技術也開始慢慢的轉為使用 Type，如同參考資料的國外大神說的『 It\u0026rsquo;s called type script not interface script』\n參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 個人認為無論使用哪一種方式都好，主要是跟團隊建立好專案的 Coding Guideline\n但若以獨立開發來說，根據過往經驗，從一開始做 Java 開發，到後來接觸前端也是習慣用 Interface 來做，畢竟這也比較接近 OOP 的概念，後續深入研究前端技術也開始慢慢的轉為使用 Type，如同參考資料的國外大神說的『 It\u0026rsquo;s called type script not interface script』\n參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 個人認為無論使用哪一種方式都好，主要是跟團隊建立好專案的 Coding Guideline\n但若以獨立開發來說，根據過往經驗，從一開始做 Java 開發，到後來接觸前端也是習慣用 Interface 來做，畢竟這也比較接近 OOP 的概念，後續深入研究前端技術也開始慢慢的轉為使用 Type 如同參考資料的國外大神說的『 It\u0026rsquo;s called type script not interface script』\n參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 個人認為無論使用哪一種方式都好，主要是跟團隊建立好專案的 Coding Guideline\n但若以獨立開發來說，根據過往經驗，從一開始做 Java 開發，到後來接觸前端也是習慣用 Interface 來做，畢竟這也比較接近 OOP 的概念，後續深入研究前端技術也開始慢慢的轉為使用 Type\n如同參考資料的國外大神說的『 It\u0026rsquo;s called type script not interface script』\n參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 個人認為無論使用哪一種方式都好，主要是跟團隊建立好專案的 Coding Guideline\n但若以獨立開發來說，根據過往經驗，從一開始做 Java 開發，到後來接觸前端也是習慣用 Interface 來做，畢竟這也比較接近 OOP 的概念，後續深入研究前端技術也開始慢慢的轉為使用 Type\n如同參考資料的國外大神說的『 It\u0026rsquo;s called type script not interface script』\n參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 個人認為無論使用哪一種方式都好，主要是跟團隊建立好專案的 Coding Guideline\n但若以獨立開發來說，根據過往經驗，從一開始做 Java 開發，到後來接觸前端也是習慣用 Interface 來做，畢竟這也比較接近 OOP 的概念，後續深入研究前端技術也開始慢慢的轉為使用 Type\n如同參考資料的國外大神說的『 It\u0026rsquo;s called type script not interface script』\n參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"},{"categories":["前端","TypeScript"],"contents":"前言 TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。\n1. 擴展(Extends)的語法差異: // Interface 使用 extends interface Animal { name: string; } interface Dog extends Animal { bark(): void; } // Type 使用 \u0026amp; type Animal = { name: string; }; type Dog = Animal \u0026amp; { bark(): void; }; 2. 合併聲明(Declaration Merging): // Interface 可以重複宣告,會自動合併 interface User { name: string; } interface User { age: number; } // 最終 User 將包含 name 和 age // Type 不能重複宣告 type User = { name: string; }; // 錯誤:不能重複宣告 type User type User = { age: number; }; 3.映射類型 (Mapped Types) // Type 可以使用更複雜的類型運算 type Keys = \u0026#39;firstname\u0026#39; | \u0026#39;lastname\u0026#39;; type DuplicateString = { [key in Keys]: string; }; // Interface 不支援映射類型，不能這樣寫 interface DuplicateString { [key in Keys]: string; // 錯誤 } 4.Tuple 和 Union 的定義: // Type 可以直接定義 type StringOrNumber = string | number; type StringArray = [string, string]; // Interface 需要間接定義 interface StringArray extends Array\u0026lt;string\u0026gt; { 0: string; 1: string; length: 2; } 結語 無論使用哪一種方式都好，主要是跟團隊建立好專案的 Coding Guideline，良好的溝通和團隊合作才是上策。\n但若以獨立開發來說，根據過往經驗，從一開始做 Java 開發，到後來接觸前端也是習慣用 Interface 來做，畢竟這也比較接近 OOP 的概念，深入研究前端技術後也開始慢慢的轉為使用 Type\n如同參考資料的國外大神說的『 It\u0026rsquo;s called type script not interface script』\n參考資料 Why use Type and not Interface in TypeScript Interfaces vs Type Aliases: what\u0026rsquo;s the difference? ","date":"2025-01-02T10:59:25+08:00","permalink":"http://localhost:1313/post/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/","section":"post","tags":null,"title":"Type 和 Interface 要用哪一個?"},{"categories":["前端","JavaScript"],"contents":"短路邏輯 （Short-Circuit Evaluation） 短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。\n優點 避免不必要的計算: 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。 提早結束迴圈: 在迴圈中使用短路邏輯可以提早結束迴圈。 避免錯誤: 在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。 簡化程式碼: 條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。 設定預設值： 可以用來設定變數的預設值。 缺點 可讀性降低: 判斷過於複雜時反而使可讀性降低。 不易維護: 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。 使用情境 當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 if...else 以提升可讀性。\n邏輯 AND (\u0026amp;\u0026amp;) let result = condition \u0026amp;\u0026amp; \u0026#34;Yes\u0026#34;; 說明： 當 condition 為 true 時，result 將會是 \u0026ldquo;Yes\u0026rdquo;；如果 condition 為 false，則 result 的值會是 condition 自己 （通常為 false 或 undefined 等）。\n💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。\n例如檢查某物件是否存在，再執行方法：isAdmin \u0026amp;\u0026amp; performAdminAction()。\n邏輯 OR (||) let result = condition || \u0026#34;Default\u0026#34;; 說明： 當 condition 為 false （如 null、undefined、0、\u0026quot;\u0026quot; 等） 時，返回 \u0026ldquo;Default\u0026rdquo;；如果 condition 為 true，則返回 condition 的值。\n💡 典型用途：為變數設定預設值。\n❗️ 注意事項 邏輯 OR (||) 與 邏輯 AND (\u0026amp;\u0026amp;)返回的是操作數本身，而非布林值。需要謹慎處理返回值的類型。\n邏輯 OR (||) 會將所有 falsy 值（例如 0, \u0026lsquo;\u0026rsquo;, null, undefined 等）視為 false；而 ?? 只針對 null 和 undefined。\n範例：\nconst value1 = 0 || \u0026#34;default\u0026#34;; // 返回 \u0026#34;default\u0026#34; const value2 = 0 ?? \u0026#34;default\u0026#34;; // 返回 0 ","date":"2024-12-30T14:41:54+08:00","permalink":"http://localhost:1313/post/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/","section":"post","tags":null,"title":"邏輯運算子 - 短路"},{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。 (關於 TDZ，我們以後會專門做一期影片跟大家講解)\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"}]