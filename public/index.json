[{"categories":["Angular","Vue"],"contents":"之前趁著 Udemy 黑五活動買了些有興趣的課程來進修，加上 YT 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。\n在自學時光是 Vue 就看了三個不同的教學影片，對於 ref、reactive 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 Angular 且版本 \u0026lt; 16 , 對於 Signals 的應用很模糊，嘗試用 Vue 的 ref 去解釋 Angular 的 Signals 好像一切都說得過去了！\nAngular Signals 的用途 Angular 引入 Signals 是為了解決 響應式狀態管理 的問題。傳統上 Angular 主要使用 RxJS 的 Observables 或 Component State 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。\nSignals 主要用途：\n響應式狀態管理： Signals 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。 效能提升： Signals 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。 同步數據流： 和 RxJS 的異步操作不同，Signals 提供 同步 的數據流，使用起來更加直觀。 預測性： Angular Signals 透過明確的讀寫 API，讓數據變更更易於預測和調試。 import { signal } from \u0026#34;@angular/core\u0026#34;; export class MyComponent { count = signal(0); increment() { this.count.set(this.count() + 1); } } signal() 用於建立可追蹤的響應式狀態。 使用 .set()、.update() 來修改值，使用 signal() 本身讀取當前值。 Vue 3 ref 的用途 Vue 3 的 ref 也用於 響應式數據 管理。ref 會將一個變數包裹成 響應式對象，當數據變化時，Vue 會自動追蹤變更並更新 UI。\nimport { ref } from \u0026#34;vue\u0026#34;; export default { setup() { const count = ref(0); function increment() { count.value++; } return { count, increment }; }, }; ref() 將一個基本值轉換為響應式變數。 使用 .value 來讀取或修改 ref 的值。 Signals 與 ref 的比較 特性 Angular Signals Vue 3 ref 核心用途 響應式狀態管理，提供同步響應式 API 響應式數據管理，適用於單一值和基本類型 變更檢測機制 精細化：僅更新變化部分 自動：根據 value 追蹤並更新 API 使用 signal() 建立，使用 .set() 修改值 ref() 建立，使用 .value 修改值 效能優化 精細控制 UI 更新，無需依賴整體變更檢測 依賴 Vue 內建的響應式系統進行優化 數據流方向 同步，明確控制狀態變化 同步，通過 Proxy 進行響應式更新 可讀性和擴展性 需顯式地設置狀態變化（例如 .set()） 透過 value 自動進行值變更 ","date":"2024-12-27T10:06:49+08:00","permalink":"http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"Angular 和 Vue 的響應式狀態管理"},{"categories":["前端","JavaScript"],"contents":"const、let 與 var var\n作用域： var是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。 Hoisting（提升）： var 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。 屬性綁定： 在全域範疇中，使用 var 宣告的變數會成為全域物件（window 或 globalThis）的屬性。 var 範例（函式作用域） var x = 10; console.log(window.x); // 10 let\n作用域： let 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。\nHoisting（提升）： 與 var 不同，let 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。\n屬性綁定： 在全域範疇中，使用 let 宣告的變數不會成為全域物件的屬性。\nlet 範例（區塊作用域） let y = 20; console.log(window.y); // undefined const\n作用域： 與 let 一樣，const 是區塊作用域（Block Scope）。\n不可重新賦值： const 宣告的變數必須在宣告時初始化，且不能重新賦值。但如果該變數儲存的是物件，其屬性可以被修改。\nHoisting（提升）： 同樣存在暫時性死區（TDZ），在宣告之前不可訪問。\n屬性綁定： 使用 const 宣告的變數，與 let 一樣，不會成為全域物件的屬性。\nconst 範例（區塊作用域） const z = 30; console.log(window.z); // undefined 💡 結論 在現代 JavaScript 開發中，推薦使用 let 和 const 取代 var，因為它們具有區塊作用域且不會污染全域物件的屬性。\nlet 適合用於需要重新賦值的變數。\nconst 適合用於不需要重新賦值的變數。\n這樣的選擇可以提高程式的可讀性與安全性，並避免不必要的作用域污染。\n","date":"2024-12-26T15:37:37+08:00","permalink":"http://localhost:1313/post/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/","section":"post","tags":null,"title":"ES6 作用域的比較"},{"categories":["note"],"contents":"以下是我根據這本書中節錄的重點整理 CH1 專業主義 不破壞軟體功能 不破壞結構(軟體要易於修改) 💡 不能銘記過去的人，註定重蹈先人的覆轍\nCH2 說「不」 專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。\n💡 說「不」，才能真正做成一些事情。\nCH3 說「是」 避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。 專業人士對自己的能力極限瞭若指掌。 回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。 💡 專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。\nCH4 寫程式 敲錯鍵盤時我自己能感覺到。\n精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。\n樂觀預估、常規預估、悲觀預估\nCH5 測試驅動開發 TDD 💡 事後寫的測試只是一種防守，先行編寫的測試則是進攻\nCH7 驗收測試 驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。\n單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。\nCH9 時間管理 會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。 Stand Up Meeting : 我昨天做了什麼? 我今天預計做什麼? 我遇到了什麼問題，需不需要協助? ","date":"2024-12-25T14:47:55+08:00","permalink":"http://localhost:1313/post/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98---%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/","section":"post","tags":null,"title":"閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道"},{"categories":null,"contents":"","date":"2024-12-24T17:22:18+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About"}]