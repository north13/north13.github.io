<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>資深菜鳥 Nick</title><link>https://north13.github.io/</link><description>Hugo theme - LoveIt</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>northn13@gmail.com (Nick)</managingEditor><webMaster>northn13@gmail.com (Nick)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 04 Jul 2025 13:55:20 +0800</lastBuildDate><atom:link href="https://north13.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript 應避免使用 any</title><link>https://north13.github.io/typescript%E6%87%89%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8any/</link><pubDate>Fri, 04 Jul 2025 13:55:20 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/typescript%E6%87%89%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8any/</guid><description><![CDATA[<p>TypeScript 的核心價值在於提供<strong>靜態類型檢查</strong>，這能夠在<strong>編譯階段</strong>就幫助我們捕獲許多潛在的錯誤，顯著提升程式碼的可靠性和可維護性。</p>
<p>然而，<code>any</code> 類型就像是 TypeScript 世界中的一個「作弊碼」或「逃生艙口」。雖然它允許你繞過所有類型檢查，但這卻抹殺了使用 TypeScript 的主要優勢。</p>
<p><strong>我們的準則：盡一切可能避免使用 <code>any</code>。</strong></p>
<hr>
<h2 id="-any-的危害使用-typescript-卻得不到的好處">🚫 <code>any</code> 的危害（使用 TypeScript 卻得不到的好處）</h2>
<table>
  <thead>
      <tr>
          <th style="text-align: left">危害</th>
          <th style="text-align: left">說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>失去類型安全</strong></td>
          <td style="text-align: left">允許你對變數進行任何操作，即使該操作在執行時會導致錯誤。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>失去自動補全</strong></td>
          <td style="text-align: left">編輯器（如 VS Code）無法推斷類型結構，導致開發效率降低。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>難以重構</strong></td>
          <td style="text-align: left">當底層資料結構改變時，依賴 <code>any</code> 的程式碼不會報錯，錯誤將在運行時爆發。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>掩蓋真實錯誤</strong></td>
          <td style="text-align: left">讓人習慣於忽略潛在的類型問題。</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="1物件屬性訪問錯誤失去類型安全">1.物件屬性訪問錯誤（失去類型安全）</h3>
<p>當我們使用 <code>any</code> 時，編譯器不會檢查我們是否正在訪問一個不存在的屬性。</p>
<h4 id="-使用-any">❌ 使用 <code>any</code></h4>
<pre><code class="language-typescript">// 使用了 any，編譯器不會報錯
function processUserData(user: any) {
  // 這裡假設我們想要訪問 'email'，但卻錯誤地寫成了 'mail'
  console.log(user.mail); // 執行時是 undefined
  return user.id.toString(); // 如果 user 沒有 id，運行時會拋出錯誤！
}

processUserData({ name: 'Nick', age: 36 }); // TS 不報錯，但運行時會出問題</code></pre>
<h4 id="-定義一個精確的-type">⭕️ 定義一個精確的 type</h4>
<pre><code class="language-typescript">// 使用 type 定義 User 結構
type UserProfile = {
  id: number;
  name: string;
  email: string;
};

function processUserDataSafe(user: UserProfile) {
  // 這裡如果寫成 user.mail，TS 會立即報錯：'Property 'mail' does not exist on type 'UserProfile'.'
  console.log(`User ID: ${user.id}, Name: ${user.name}`);
  return user.id.toString();
}

// 傳入錯誤的物件結構時，TS 會在編譯階段就提示錯誤
// processUserDataSafe({ name: 'Nick', age: 36 }); // TS 報錯：缺少屬性 'id' 和 'email'
processUserDataSafe({ id: 101, name: 'Nick', email: 'nick@example.com' }); // 正常運行</code></pre>
<h3 id="2函式輸入參數與回傳值難以重構和追蹤">2.函式輸入參數與回傳值（難以重構和追蹤）</h3>
<p>在函式參數和回傳值上使用 <code>any</code> 會使得函式的行為變得模糊，難以理解它的預期輸入和輸出。</p>]]></description></item><item><title>Record 是什麼？</title><link>https://north13.github.io/record%E6%98%AF%E4%BB%80%E9%BA%BC/</link><pubDate>Mon, 12 May 2025 10:39:45 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/record%E6%98%AF%E4%BB%80%E9%BA%BC/</guid><description><![CDATA[<h3 id="什麼是-record">什麼是 Record？</h3>
<p><strong>Record</strong> 是一種新的資料類型，用來表示一組有序的值集合，包含具名或未具名欄位。可以想像成是不需要先定義一個 <strong>class</strong> 的 <strong>「輕量級的物件」</strong> 。</p>
<h5 id="不具名-record"><code>不具名</code> Record</h5>
<pre><code class="language-dart">var record = ('Nick', 35);
print(record.$1); // Nick
print(record.$2); // 35</code></pre>
<h5 id="具名-record"><code>具名</code> Record</h5>
<pre><code class="language-dart">var record = (name: 'Nick', age: 35);
print(record.name); // Nick
print(record.age);  // 35</code></pre>
<h5 id="混合型-record"><code>混合型</code> Record</h5>
<pre><code class="language-dart">var record = ('Nick', age: 35);
print(record.$1);   // Nick
print(record.age);  // 35</code></pre>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="為什麼有-record">為什麼有 Record？</h3>
<p>如果 <strong>Dart</strong> 函數要回傳多個值，通常要用 <strong>class</strong> 或 <strong>Map</strong>，但這樣太冗長或效能不佳。而 <strong>Record</strong> 的應用有</p>
<ul>
<li>更簡潔的語法</li>
<li>更好的編譯期型別檢查</li>
<li>更快的效能（比 Map 好）</li>
</ul>
<h4 id="-使用-map-不建議">❌ 使用 Map (不建議)</h4>
<pre><code class="language-dart">Map<String, dynamic> getUser() => {
  'name': 'Nick',
  'age': 35,
  'isMember': true
};

var user = getUser();
print(user['nameee']); // ❌ 錯字或 key 不存在不會報錯</code></pre>
<h4 id="-使用-class-不建議">❌ 使用 Class (不建議)</h4>
<pre><code class="language-dart">class User {
  final String name;
  final int age;
  final bool isMember;
  User(this.name, this.age, this.isMember);
}</code></pre>
<h4 id="-使用-record-建議">⭕️ 使用 Record (建議)</h4>
<pre><code class="language-dart">({String name, int age, bool isMember}) user = (name: 'Nick', age: 35, isMember: true);</code></pre>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="模式匹配pattern-matching">模式匹配（pattern matching）</h3>
<p>它讓你像在 <strong>「解構資料」</strong> 一樣地做條件判斷或資料抽取。類似你在 <strong>JavaScript</strong> 用 <code>const { name } = user</code></p>]]></description></item><item><title>Ref 與 Reactive</title><link>https://north13.github.io/ref%E8%88%87reactive%E7%9A%84%E5%B7%AE%E7%95%B0/</link><pubDate>Mon, 13 Jan 2025 14:37:42 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/ref%E8%88%87reactive%E7%9A%84%E5%B7%AE%E7%95%B0/</guid><description><![CDATA[<p>這篇主要記錄關於 <code>Vue</code> 的 <code>ref</code> 和 <code>reactive</code>詳細內容和範例，之前寫過一篇 <strong>Angular</strong> 和 <strong>Vue</strong> 中使用響應式狀態的介紹，可參考 <strong><a href="http://localhost:1313/post/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener noreffer ">Angular 和 Vue 的響應式狀態管理</a></strong></p>
<h3 id="ref-範例"><code>Ref</code> 範例</h3>
<pre><code class="language-ts">// 基本類型使用 ref
const count = ref(0);

// 需要使用 .value 來修改值
function increment() {
  count.value++;
}

// ref 也可以包裝物件
const user = ref({
  name: 'John',
  age: 25,
});

// 物件屬性修改也需要 .value
function updateUser() {
  user.value.age++;
}</code></pre>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="reactive-範例"><code>Reactive</code> 範例</h3>
<pre><code class="language-ts">// 物件、陣列使用 reactive
let user = reactive({
  name: 'Mary',
  age: 30,
});

let arr = reactive(['Vue', 'Angular', 'React']);

// 直接修改屬性，不需要 .value
function updateSettings() {
  user.age += 1;
}

// reactive 不能用於基本類型
const count = reactive(33); // error</code></pre>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="-解構-reactive">❌ 解構 Reactive</h3>
<pre><code class="language-ts">let { name, age } = user;
user.name = 'John';
console.log(name); // 'Mary'</code></pre>
<p>解構會從響應式對象中取值，並將其存入新的變數中，這些變數（<code>name</code> 和 <code>age</code>）僅僅是值，不再是響應式的。它們不會隨著 <code>user.name</code> 或 <code>user.age</code> 的變化而變化。</p>]]></description></item><item><title>JavaScript 閉包(Closure)</title><link>https://north13.github.io/javascript-%E9%96%89%E5%8C%85closure/</link><pubDate>Thu, 09 Jan 2025 15:35:23 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/javascript-%E9%96%89%E5%8C%85closure/</guid><description><![CDATA[<h4 id="什麼是閉包closure">什麼是閉包(Closure)</h4>
<p><em><code>你知道什麼是 JS 的閉包(Closure)嗎？</code></em></p>
<p>追蹤了不少國內外的工程師 Youtuber，某次在 YT 首頁看到 Closure 的影片縮圖大吃一驚</p>
<p>一開始看到這個名詞時完全沒有頭緒，學過 var、let、const、作用域、this&hellip;等</p>
<p>居然漏掉了什麼沒學到嗎!? 這怎麼可以!!</p>
<p>拜讀了幾篇文章和影片後才發現，其實閉包無所不在，或許在不經意的情況下都寫過了勒!</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h4 id="範例">範例</h4>
<pre><code class="language-typescript">const bankAccount = (function () {
  let balance: number = 0;

  function validateAmount(amount: number): boolean {
    return amount > 0;
  }

  return {
    deposit: function (amount: number): string {
      if (!validateAmount(amount)) {
        return '請輸入有效金額';
      }
      balance += amount;
      return `存款成功，當前餘額: ${balance}`;
    },

    withdraw: function (amount: number): string {
      if (!validateAmount(amount)) {
        return '請輸入有效金額';
      }
      if (amount > balance) {
        return '餘額不足';
      }
      balance -= amount;
      return `當前餘額: ${balance}`;
    },

    getBalance: function (): string {
      return `當前餘額: ${balance}`;
    },
  };
})();

console.log(bankAccount.getBalance()); // 當前餘額: 0
console.log(bankAccount.deposit(1000)); // 存款成功，當前餘額: 1000
console.log(bankAccount.withdraw(500)); // 提款成功，當前餘額: 500
console.log(bankAccount.withdraw(1000)); // 餘額不足

// 無法直接訪問私有變數和方法
console.log(bankAccount.balance); // undefined
console.log(bankAccount.validateAmount); // undefined</code></pre>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h4 id="這個例子展示了閉包的幾個重要特點">這個例子展示了閉包的幾個重要特點：</h4>
<ol>
<li>閉包能夠「記住」外層函式的變數
在例子中，<code>balance</code> 是 <code>bankAccount</code> 的私有變數，但因為 <code>deposit</code>、<code>withdraw</code>、<code>getBalance</code> 在內部被 <strong>return</strong>，這些 <strong>function</strong> 形成閉包，可以持續訪問這些變數，即使外層函式已經執行完成。</li>
</ol>
<pre><code class="language-typescript">let balance: number = 0;

return {
  deposit: function (amount: number): string {
    if (!validateAmount(amount)) {
      return '請輸入有效金額';
    }
    balance += amount;
    return `存款成功，當前餘額: ${balance}`;
  },
  // 其他方法同理
};</code></pre>
<p>這段程式碼中，<code>balance</code> 是閉包捕獲的變數，這些變數的值會根據執行的操作（例如存款或提款）而變化，並且被所有內部函式共享。</p>]]></description></item><item><title>Type 和 Interface 要用哪一個?</title><link>https://north13.github.io/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/</link><pubDate>Thu, 02 Jan 2025 10:59:25 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/type%E5%92%8Cinterface%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%80%E5%80%8B/</guid><description><![CDATA[<h2 id="前言">前言</h2>
<p>TypeScript 中，Type 與 Interface 都是用來定義型別的關鍵字，但兩者之間存在著些許的差異。以下將深入探討 Type 與 Interface 的特性，並建議在不同的情境下如何選擇適合的型別定義方式，以提升 TypeScript 程式碼的可讀性與維護性。</p>
<h5 id="1-擴展extends的語法差異">1. 擴展(Extends)的語法差異:</h5>
<pre><code class="language-typescript">// Interface 使用 extends
interface Animal {
  name: string;
}

interface Dog extends Animal {
  bark(): void;
}

// Type 使用 &
type Animal = {
  name: string;
};

type Dog = Animal & {
  bark(): void;
};</code></pre>
<h5 id="2-合併聲明declaration-merging">2. 合併聲明(Declaration Merging):</h5>
<pre><code class="language-ts">// Interface 可以重複宣告,會自動合併
interface User {
  name: string;
}

interface User {
  age: number;
}
/* 最終 User 將包含 name 和 age */

// Type 不能重複宣告
type User = {
  name: string;
};

// 錯誤:不能重複宣告 type User
type User = {
  age: number;
};</code></pre>
<h5 id="3映射類型-mapped-types">3.映射類型 (Mapped Types)</h5>
<pre><code class="language-ts">// Type 可以使用更複雜的類型運算
type Keys = 'firstname' | 'lastname';
type DuplicateString = {
  [key in Keys]: string;
};

// Interface 不支援映射類型，不能這樣寫
interface DuplicateString {
  [key in Keys]: string; // 錯誤
}</code></pre>
<h5 id="4tuple-和-union-的定義">4.Tuple 和 Union 的定義:</h5>
<pre><code class="language-ts">// Type 可以直接定義
type StringOrNumber = string | number;
type StringArray = [string, string];

// Interface 需要間接定義
interface StringArray extends Array<string> {
  0: string;
  1: string;
  length: 2;
}</code></pre>
<h3 id="-結論">💡 結論</h3>
<blockquote>
<p>無論使用哪一種方式都好，主要是跟團隊建立好專案的 <code>Coding Guideline</code>，良好的溝通和團隊合作才是上策。</p>]]></description></item><item><title>邏輯運算子 - 短路</title><link>https://north13.github.io/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/</link><pubDate>Mon, 30 Dec 2024 14:41:54 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E7%9F%AD%E8%B7%AF/</guid><description><![CDATA[<h2 id="短路邏輯-short-circuit-evaluation">短路邏輯 （Short-Circuit Evaluation）</h2>
<p>短路邏輯是一種邏輯運算的優化技巧，用於進行邏輯判斷時，當確定結果時立即停止後續的運算，也因為在某些情況並不需要計算所有的運算元就能確定結果，所以稱為「短路」。</p>
<h3 id="優點">優點</h3>
<ol>
<li><strong>避免不必要的計算:</strong> 當邏輯運算的結果可以由前面的運算元確定時，後面的運算元就不會被計算，這可以節省計算資源，提高程式執行效率。</li>
<li><strong>提早結束迴圈:</strong> 在迴圈中使用短路邏輯可以提早結束迴圈。</li>
<li><strong>避免錯誤:</strong>
在檢查物件是否為 null 的時候，使用短路邏輯可以避免在 null 物件上呼叫方法而引發 NullPointerException。</li>
<li><strong>簡化程式碼:</strong>
<ul>
<li>條件判斷： 短路邏輯可以簡化條件判斷，讓程式碼更簡潔。</li>
<li>設定預設值： 可以用來設定變數的預設值。</li>
</ul>
</li>
</ol>
<h3 id="缺點">缺點</h3>
<ol>
<li><strong>可讀性降低:</strong> 判斷過於複雜時反而使可讀性降低。</li>
<li><strong>不易維護:</strong> 過度使用短路邏輯可能會讓程式碼難以理解，降低可維護性。</li>
</ol>
<h3 id="使用情境">使用情境</h3>
<p>當條件簡單或主要為賦值判斷時，短路邏輯是非常好的方式；但如果判斷過於複雜，建議使用 <code>if...else</code> 以提升可讀性。</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="邏輯-and-">邏輯 AND (&amp;&amp;)</h3>
<pre><code class="language-js">let result = condition && "Yes";</code></pre>
<p>說明：
當 condition 為 <code>true</code> 時，result 將會是 &ldquo;Yes&rdquo;；如果 condition 為 <code>false</code>，則 result 的值會是 condition 自己 <strong>（通常為 false 或 undefined 等）</strong>。</p>
<blockquote>
<p>💡 典型用途：用於在條件為 true 時執行某些操作，否則忽略。</p>
<p>例如檢查某物件是否存在，再執行方法：isAdmin &amp;&amp; performAdminAction()。</p>]]></description></item><item><title>Angular 和 Vue 的響應式狀態管理</title><link>https://north13.github.io/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/</link><pubDate>Fri, 27 Dec 2024 10:06:49 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/angular%E5%92%8Cvue%E7%9A%84%E9%9F%BF%E6%87%89%E5%BC%8F%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/</guid><description><![CDATA[<p>之前趁著 <code>Udemy</code> 黑五活動買了些有興趣的課程來進修，加上 <code>YT</code> 上免費的課程，聽聽不同的講師會有不同的收穫，就像是看醫生不要只看一間，不同的醫生看或許會有不同的見解。</p>
<p>在自學時光是 <code>Vue</code> 就看了三個不同的教學影片，對於 <code>ref</code>、<code>reactive</code> 雖無實務經驗，但有一定程度的瞭解。之前工作上使用的框架是 <code>Angular</code> 且版本 <strong>&lt; 16</strong> , 對於 <code>Signals</code> 的應用很模糊，嘗試用 <code>Vue</code> 的 <code>ref</code> 去解釋 <code>Angular</code> 的 <code>Signals</code> 好像一切都說得過去了！</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="angular-signals-的用途"><strong>Angular Signals 的用途</strong></h3>
<p><code>Angular</code> 引入 <strong>Signals</strong> 是為了解決 <strong>響應式狀態管理</strong> 的問題。傳統上 <code>Angular</code> 主要使用 <code>RxJS</code> 的 <code>Observables</code> 或 <code>Component State</code> 來管理狀態，但這種方式可能導致程式碼複雜性增加、追蹤數據變化困難。</p>
<p><strong>Signals 主要用途：</strong></p>
<ol>
<li><strong>響應式狀態管理：</strong> <code>Signals</code> 允許你輕鬆追蹤和響應狀態變化，無需手動訂閱或處理變更檢測。</li>
<li><strong>效能提升：</strong> <code>Signals</code> 會在狀態變化時自動觸發 UI 更新，並只更新受影響的部分，而非整體重新渲染，這比傳統變更檢測更高效。</li>
<li><strong>同步數據流：</strong> 和 <code>RxJS</code> 的異步操作不同，<code>Signals</code> 提供 <strong>同步</strong> 的數據流，使用起來更加直觀。</li>
<li><strong>預測性：</strong> <code>Angular Signals</code> 透過明確的讀寫 <code>API</code>，讓數據變更更易於預測和調試。</li>
</ol>
<pre><code class="language-jsx">import { signal } from "@angular/core";

export class MyComponent {
  count = signal(0);

  increment() {
    this.count.set(this.count() + 1);
  }
}</code></pre>
<ul>
<li><code>signal()</code> 用於建立可追蹤的響應式狀態。</li>
<li>使用 <code>.set()</code>、<code>.update()</code> 來修改值，使用 <code>signal()</code> 本身讀取當前值。</li>
</ul>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="vue-3-ref-的用途"><strong>Vue 3 ref 的用途</strong></h3>
<p><code>Vue 3</code> 的 <code>ref</code> 也用於 響應式數據 管理。<code>ref</code> 會將一個變數包裹成 響應式對象，當數據變化時，<code>Vue</code> 會自動追蹤變更並更新 UI。</p>]]></description></item><item><title>ES6 作用域的比較</title><link>https://north13.github.io/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/</link><pubDate>Thu, 26 Dec 2024 15:37:37 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/es6-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%AF%94%E8%BC%83/</guid><description><![CDATA[<h2 id="constlet-與-var">const、let 與 var</h2>
<p><code>var</code></p>
<ul>
<li><strong>作用域：</strong>
<code>var</code>是函式作用域（Function Scope）。在函式內宣告的變數僅在該函式內可用，若在函式外使用，則為全域作用域（Global Scope）。</li>
<li><strong>Hoisting（提升）：</strong>
<code>var</code> 宣告的變數會被提升到作用域的頂部（包括全域和函式內部），但初始化的值不會提升。</li>
<li><strong>屬性綁定：</strong>
在全域範疇中，使用 <code>var</code> 宣告的變數會成為全域物件（window 或 globalThis）的屬性。</li>
</ul>
<h3 id="var-範例函式作用域">var 範例（函式作用域）</h3>
<pre><code class="language-js">var x = 10;
console.log(window.x); // 10</code></pre>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p><code>let</code></p>
<ul>
<li>
<p><strong>作用域：</strong>
<code>let</code> 是區塊作用域（Block Scope），也就是變數僅在其所宣告的區塊 {} 內有效。</p>
</li>
<li>
<p><strong>Hoisting（提升）：</strong>
與 <code>var</code> 不同，<code>let</code> 變數在宣告之前不可訪問，會觸發「暫時性死區」（Temporal Dead Zone, TDZ）。
(<del><em>關於 TDZ，我們以後會專門做一期影片跟大家講解</em></del>)</p>
</li>
<li>
<p><strong>屬性綁定：</strong>
在全域範疇中，使用 <code>let</code> 宣告的變數不會成為全域物件的屬性。</p>
</li>
</ul>
<h3 id="let-範例區塊作用域">let 範例（區塊作用域）</h3>
<pre><code class="language-js">let y = 20;
console.log(window.y); // undefined</code></pre>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p><code>const</code></p>
<ul>
<li>
<p><strong>作用域：</strong>
與 <code>let</code> 一樣，<code>const</code> 是區塊作用域（Block Scope）。</p>]]></description></item><item><title>閱讀筆記 - The Clean Coder 無暇程式碼番外篇 - 專業程式設計師的生存之道</title><link>https://north13.github.io/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98-%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/</link><pubDate>Wed, 25 Dec 2024 14:47:55 +0800</pubDate><author>northn13@gmail.com (Nick)</author><guid>https://north13.github.io/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98-%E7%84%A1%E6%9A%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%95%AA%E5%A4%96%E7%AF%87/</guid><description><![CDATA[<h2 id="以下是我根據這本書中節錄的重點整理">以下是我根據這本書中節錄的重點整理</h2>
<h3 id="ch1-專業主義">CH1 專業主義</h3>
<ol>
<li>不破壞軟體功能</li>
<li>不破壞結構(軟體要易於修改)</li>
</ol>
<blockquote>
<p>💡 <strong>不能銘記過去的人，註定重蹈先人的覆轍</strong></p>
</blockquote>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="ch2-說不">CH2 說「不」</h3>
<p>專業人士敢於說明真相而不屈從於權勢。有勇氣說「不」。</p>
<blockquote>
<p>💡 <strong>說「不」，才能真正做成一些事情。</strong></p>
</blockquote>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="ch3-說是">CH3 說「是」</h3>
<ol>
<li>避免「缺乏承諾」，若是無法達成應盡早向承諾的對象發出預警，越早、越快越好。</li>
<li>專業人士對自己的能力極限瞭若指掌。</li>
<li>回歸測試 ( Regression Testing ) 是當程式進行修改後，檢查修改前能正常執行的功能是否仍能無誤的執行。</li>
</ol>
<blockquote>
<p>💡 <strong>專業人士不需要對所有的請求都回答「是」。不過，他們應該努力尋找創新的方法，盡可能做到有求必應。當專業人士給出肯定回答時，會使用「承諾用語」，以確保各方能無誤的明白及理解承諾的內容。</strong></p>
</blockquote>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="ch4-寫程式">CH4 寫程式</h3>
<p><strong>敲錯鍵盤時我自己能感覺到。</strong></p>
<p>精熟掌握每項技藝，關鍵都是要具備「信心」和「出錯感知」。</p>
<p>樂觀預估、常規預估、悲觀預估</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="ch5-測試驅動開發-tdd">CH5 測試驅動開發 TDD</h3>
<blockquote>
<p>💡 <strong>事後寫的測試只是一種防守，先行編寫的測試則是進攻</strong></p>
</blockquote>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="ch7-驗收測試">CH7 驗收測試</h3>
<p>驗收測試和單元測試的對象通常是相同的，但絕對和「重複」沾不上邊。</p>
<p>單元測試是深入系統內部進行，呼叫特定類別的方法；驗收測試則是在系統外部，通常是在 API 或 UI 層級進行。所以兩者的執行路徑截然不同。</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="ch9-時間管理">CH9 時間管理</h3>
<ul>
<li>會議是必須的，但會議會浪費大量時間，沒有必要的會議應禮貌拒絕。</li>
<li>Stand Up Meeting :
<ol>
<li>我昨天做了什麼?</li>
<li>我今天預計做什麼?</li>
<li>我遇到了什麼問題，需不需要協助?</li>
</ol>
</li>
</ul>]]></description></item></channel></rss>